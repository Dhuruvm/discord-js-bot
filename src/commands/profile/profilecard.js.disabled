const { AttachmentBuilder, ApplicationCommandOptionType, EmbedBuilder } = require("discord.js");
const { createCanvas, loadImage } = require("canvas");
const { EMBED_COLORS } = require("@root/config");
const ModernEmbed = require("@helpers/ModernEmbed");
const { getUser } = require("@schemas/User");
const { getBanner } = require("@helpers/BannerStore");
const emojis = require("@root/emojis.json");

module.exports = {
  name: "profile",
  description: "Generate a sleek Discord profile card",
  category: "GRAPHICS",
  botPermissions: ["AttachFiles"],
  cooldown: 3,
  command: {
    enabled: false,
    aliases: ["pf", "card"],
    usage: "[user]",
    minArgsCount: 0,
  },
  slashCommand: {
    enabled: false,
    options: [
      {
        name: "user",
        description: "The user to generate a profile card for",
        type: ApplicationCommandOptionType.User,
        required: false,
      },
    ],
  },

  async messageRun(message, args) {
    try {
      await message.channel.sendTyping();
      
      const user = message.mentions.users.first() || message.author;
      const member = await message.guild.members.fetch(user.id).catch(() => null);
      const userDb = await getUser(user);
      
      const buffer = await generateProfileCard(user, member, userDb);
      const attachment = new AttachmentBuilder(buffer, { name: "profile.png" });
      
      await message.safeReply({ files: [attachment] });
    } catch (error) {
      message.client.logger.error("Error generating profile card:", error);
      await message.safeReply(ModernEmbed.simpleError("Failed to generate profile card. Please try again later."));
    }
  },

  async interactionRun(interaction) {
    await interaction.deferReply();
    
    try {
      const user = interaction.options.getUser("user") || interaction.user;
      const member = await interaction.guild.members.fetch(user.id).catch(() => null);
      const userDb = await getUser(user);
      
      const buffer = await generateProfileCard(user, member, userDb);
      const attachment = new AttachmentBuilder(buffer, { name: "profile.png" });
      
      await interaction.followUp({ files: [attachment] });
    } catch (error) {
      interaction.client.logger.error("Error generating profile card:", error);
      await interaction.followUp(ModernEmbed.simpleError("Failed to generate profile card. Please try again later."));
    }
  },
};

async function generateProfileCard(user, member, userDb) {
  const width = 800;
  const height = 1000;
  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext("2d");

  // Get user's accent color or use default
  const accentColor = userDb?.profile?.accentColor || "#5865F2";
  const theme = userDb?.profile?.theme || "dark";
  
  // Background
  const bgColor = theme === "dark" ? "#0F0F0F" : "#FFFFFF";
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, width, height);

  // Main card container
  const cardX = 30;
  const cardY = 30;
  const cardWidth = width - 60;
  const cardHeight = height - 60;
  const cornerRadius = 20;

  // Card background with subtle gradient
  ctx.save();
  ctx.beginPath();
  roundRect(ctx, cardX, cardY, cardWidth, cardHeight, cornerRadius);
  ctx.clip();
  
  const cardBg = theme === "dark" ? "#1A1A1A" : "#F5F5F5";
  ctx.fillStyle = cardBg;
  ctx.fillRect(cardX, cardY, cardWidth, cardHeight);
  ctx.restore();

  // Banner section
  const bannerHeight = 280;
  ctx.save();
  ctx.beginPath();
  roundRect(ctx, cardX, cardY, cardWidth, bannerHeight, cornerRadius, true, false);
  ctx.clip();

  // Try to load Discord banner first
  let bannerLoaded = false;
  try {
    const bannerURL = user.bannerURL({ size: 1024, extension: "png" });
    if (bannerURL) {
      const bannerImg = await loadImage(bannerURL);
      ctx.drawImage(bannerImg, cardX, cardY, cardWidth, bannerHeight);
      bannerLoaded = true;
    }
  } catch (error) {
    // Banner loading failed, will use fallback
  }

  // Fallback to custom banner if no Discord banner
  if (!bannerLoaded) {
    const bannerKey = userDb?.profile?.banner || "gradient_blue";
    const bannerConfig = getBanner(bannerKey);
    
    if (bannerConfig.type === "gradient") {
      drawModernGradient(ctx, cardX, cardY, cardWidth, bannerHeight, bannerConfig.colors, accentColor);
    } else if (bannerConfig.type === "pattern") {
      drawPatternBanner(ctx, cardX, cardY, cardWidth, bannerHeight, bannerConfig);
    } else if (bannerConfig.type === "special") {
      drawSpecialBanner(ctx, cardX, cardY, cardWidth, bannerHeight, bannerConfig);
    } else {
      // Default modern gradient
      drawModernGradient(ctx, cardX, cardY, cardWidth, bannerHeight, [accentColor, "#8B5CF6", "#EC4899"], accentColor);
    }
  }

  // Banner overlay gradient for depth
  const overlayGradient = ctx.createLinearGradient(cardX, cardY + bannerHeight - 100, cardX, cardY + bannerHeight);
  overlayGradient.addColorStop(0, "rgba(0,0,0,0)");
  overlayGradient.addColorStop(1, cardBg);
  ctx.fillStyle = overlayGradient;
  ctx.fillRect(cardX, cardY, cardWidth, bannerHeight);

  ctx.restore();

  // Avatar settings
  const avatarSize = 160;
  const avatarX = width / 2;
  const avatarY = cardY + bannerHeight - 50;

  // Modern avatar glow effect
  ctx.save();
  ctx.shadowColor = hexToRGBA(accentColor, 0.6);
  ctx.shadowBlur = 40;
  
  // Outer ring
  ctx.beginPath();
  ctx.arc(avatarX, avatarY, avatarSize / 2 + 8, 0, Math.PI * 2);
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = 6;
  ctx.stroke();
  ctx.restore();

  // Avatar background
  ctx.beginPath();
  ctx.arc(avatarX, avatarY, avatarSize / 2 + 4, 0, Math.PI * 2);
  ctx.fillStyle = cardBg;
  ctx.fill();

  // Draw avatar
  try {
    const avatar = await loadImage(user.displayAvatarURL({ size: 512, extension: "png" }));
    
    ctx.save();
    ctx.beginPath();
    ctx.arc(avatarX, avatarY, avatarSize / 2, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();
    ctx.drawImage(avatar, avatarX - avatarSize / 2, avatarY - avatarSize / 2, avatarSize, avatarSize);
    ctx.restore();
  } catch (error) {
    // Avatar loading failed
  }

  // Status indicator
  const status = member?.presence?.status || "offline";
  const statusColors = {
    online: "#23A559",
    idle: "#F0B232",
    dnd: "#F23F43",
    offline: "#80848E",
  };

  const statusSize = 36;
  const statusX = avatarX + avatarSize / 2 - statusSize / 2;
  const statusY = avatarY + avatarSize / 2 - statusSize / 2;

  // Status background
  ctx.beginPath();
  ctx.arc(statusX, statusY, statusSize / 2 + 2, 0, Math.PI * 2);
  ctx.fillStyle = cardBg;
  ctx.fill();

  // Status indicator
  ctx.beginPath();
  ctx.arc(statusX, statusY, statusSize / 2, 0, Math.PI * 2);
  ctx.fillStyle = statusColors[status];
  ctx.fill();

  // Username section
  const textColor = theme === "dark" ? "#FFFFFF" : "#000000";
  const secondaryColor = theme === "dark" ? "#B5BAC1" : "#6B7280";
  
  const usernameY = avatarY + avatarSize / 2 + 90;
  
  // Username with modern font
  ctx.fillStyle = textColor;
  ctx.font = "bold 56px 'Segoe UI', Arial, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(user.username, avatarX, usernameY);

  // Global name or tag
  const globalName = user.globalName || user.username;
  if (globalName !== user.username) {
    ctx.fillStyle = secondaryColor;
    ctx.font = "32px 'Segoe UI', Arial, sans-serif";
    ctx.fillText(`@${user.username}`, avatarX, usernameY + 48);
  }

  // Bio section with modern styling
  let bioText = userDb?.profile?.bio;
  
  if (!bioText && member) {
    const roles = member.roles.cache
      .filter((r) => r.id !== member.guild.id)
      .sort((a, b) => b.position - a.position)
      .map((r) => r.name)
      .slice(0, 3);
    
    if (roles.length > 0) {
      bioText = roles.join(" â€¢ ");
    }
  }

  if (!bioText) {
    bioText = "Discord User";
  }

  // Bio container
  const bioY = globalName !== user.username ? usernameY + 130 : usernameY + 90;
  const bioBoxY = bioY - 30;
  const bioBoxHeight = 120;

  // Semi-transparent bio background
  ctx.fillStyle = theme === "dark" ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.03)";
  roundRect(ctx, cardX + 40, bioBoxY, cardWidth - 80, bioBoxHeight, 12);
  ctx.fill();

  // Bio text with word wrap
  ctx.fillStyle = secondaryColor;
  ctx.font = "28px 'Segoe UI', Arial, sans-serif";
  ctx.textAlign = "center";
  
  const maxWidth = cardWidth - 120;
  wrapText(ctx, bioText, avatarX, bioY + 20, maxWidth, 40);

  // Activity section if available
  if (member?.presence?.activities && member.presence.activities.length > 0) {
    const activity = member.presence.activities[0];
    const activityY = bioBoxY + bioBoxHeight + 60;

    // Activity container
    ctx.fillStyle = theme === "dark" ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.03)";
    roundRect(ctx, cardX + 40, activityY, cardWidth - 80, 90, 12);
    ctx.fill();

    // Accent bar on left
    ctx.fillStyle = accentColor;
    ctx.fillRect(cardX + 40, activityY, 6, 90);

    // Activity text
    ctx.textAlign = "left";
    ctx.fillStyle = textColor;
    ctx.font = "bold 26px 'Segoe UI', Arial, sans-serif";
    
    let activityLabel = "Activity";
    if (activity.type === 0) activityLabel = "Playing";
    else if (activity.type === 2) activityLabel = "Listening to";
    else if (activity.type === 3) activityLabel = "Watching";
    else if (activity.type === 5) activityLabel = "Competing in";
    
    ctx.fillText(activityLabel, cardX + 70, activityY + 35);
    
    ctx.fillStyle = secondaryColor;
    ctx.font = "24px 'Segoe UI', Arial, sans-serif";
    const activityName = activity.name || activity.state || "Unknown";
    ctx.fillText(activityName.slice(0, 50), cardX + 70, activityY + 65);
  }

  // Footer with accent line
  const footerY = cardY + cardHeight - 40;
  ctx.fillStyle = hexToRGBA(accentColor, 0.3);
  ctx.fillRect(cardX + 40, footerY, cardWidth - 80, 2);

  // Subtle watermark
  ctx.fillStyle = hexToRGBA(secondaryColor, 0.5);
  ctx.font = "20px 'Segoe UI', Arial, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Powered by Cybork", avatarX, footerY + 25);

  return canvas.toBuffer("image/png");
}

function roundRect(ctx, x, y, width, height, radius, fill = true, stroke = false) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

function drawModernGradient(ctx, x, y, width, height, colors, accentColor) {
  // Modern mesh gradient effect
  const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
  
  if (colors && colors.length > 0) {
    colors.forEach((color, i) => {
      gradient.addColorStop(i / (colors.length - 1), color);
    });
  } else {
    gradient.addColorStop(0, accentColor || "#5865F2");
    gradient.addColorStop(0.5, "#8B5CF6");
    gradient.addColorStop(1, "#EC4899");
  }

  ctx.fillStyle = gradient;
  ctx.fillRect(x, y, width, height);

  // Add noise/texture overlay for depth
  ctx.globalAlpha = 0.05;
  for (let i = 0; i < 1000; i++) {
    const noiseX = x + Math.random() * width;
    const noiseY = y + Math.random() * height;
    ctx.fillStyle = Math.random() > 0.5 ? "#FFFFFF" : "#000000";
    ctx.fillRect(noiseX, noiseY, 1, 1);
  }
  ctx.globalAlpha = 1;
}

function drawPatternBanner(ctx, x, y, width, height, config) {
  const baseGradient = ctx.createLinearGradient(x, y, x, y + height);
  baseGradient.addColorStop(0, config.baseColors[0]);
  baseGradient.addColorStop(1, config.baseColors[1]);
  ctx.fillStyle = baseGradient;
  ctx.fillRect(x, y, width, height);

  ctx.globalAlpha = 0.15;

  if (config.name.includes("Stars")) {
    for (let i = 0; i < 80; i++) {
      const starX = x + Math.random() * width;
      const starY = y + Math.random() * height;
      const starSize = Math.random() * 2.5 + 0.5;

      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(starX, starY, starSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.globalAlpha = 1;
}

function drawSpecialBanner(ctx, x, y, width, height, config) {
  if (config.name.includes("Holographic") || config.name.includes("Neon")) {
    const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
    config.colors.forEach((color, i) => {
      gradient.addColorStop(i / (config.colors.length - 1), color);
    });
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, width, height);
  }
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  const words = text.split(" ");
  let line = "";
  let currentY = y;

  for (let i = 0; i < words.length; i++) {
    const testLine = line + words[i] + " ";
    const metrics = ctx.measureText(testLine);
    
    if (metrics.width > maxWidth && i > 0) {
      ctx.fillText(line.trim(), x, currentY);
      line = words[i] + " ";
      currentY += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line.trim(), x, currentY);
}

function hexToRGBA(hex, alpha = 1) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
